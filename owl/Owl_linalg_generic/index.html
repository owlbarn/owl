<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Owl_linalg_generic (owl.Owl_linalg_generic)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">owl</a> &#x00BB; Owl_linalg_generic</nav><header class="odoc-preamble"><h1>Module <code><span>Owl_linalg_generic</span></code></h1><p>Linear algebra module including high-level functions to solve linear systems, factorisation, and etc.</p></header><nav class="odoc-toc"><ul><li><a href="#type-definition">Type definition</a></li><li><a href="#basic-functions">Basic functions</a></li><li><a href="#check-matrix-types">Check matrix types</a></li><li><a href="#factorisation">Factorisation</a></li><li><a href="#eigenvalues-&amp;-eigenvectors">Eigenvalues &amp; eigenvectors</a></li><li><a href="#linear-system-of-equations">Linear system of equations</a></li><li><a href="#low-level-factorisation-functions">Low-level factorisation functions</a></li><li><a href="#matrix-functions">Matrix functions</a></li><li><a href="#helper-functions">Helper functions</a></li></ul></nav><div class="odoc-content"><p>The module includes a set of advanced linear algebra operations such as singular value decomposition, and etc.</p><p>Currently, Linalg module supports dense matrix of four different number types, including <code>float32</code>, <code>float64</code>, <code>complex32</code>, and <code>complex64</code>. The support for sparse matrices will be provided in future.</p><h6 id="type-definition"><a href="#type-definition" class="anchor"></a>Type definition</h6><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b) t</span></span><span> = <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../Owl_dense_matrix_generic/index.html#type-t">Owl_dense_matrix_generic.t</a></span></span></code></div><div class="spec-doc"><p>Matrix type, a special case of N-dimensional array.</p></div></div><h6 id="basic-functions"><a href="#basic-functions" class="anchor"></a>Basic functions</h6><div class="odoc-spec"><div class="spec value anchored" id="val-inv"><a href="#val-inv" class="anchor"></a><code><span><span class="keyword">val</span> inv : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>inv x</code> calculates the inverse of an invertible square matrix <code>x</code> such that <code>x *@ x = I</code> wherein <code>I</code> is an identity matrix. (If <code>x</code> is singular, <code>inv</code> will return a useless result.)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pinv"><a href="#val-pinv" class="anchor"></a><code><span><span class="keyword">val</span> pinv : <span>?tol:float <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>pinv x</code> computes Moore-Penrose pseudoinverse of matrix <code>x</code>. <code>tol</code> specifies the tolerance, the absolute value of the elements smaller than <code>tol</code> will be set to zeros.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-det"><a href="#val-det" class="anchor"></a><code><span><span class="keyword">val</span> det : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>det x</code> computes the determinant of a square matrix <code>x</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-logdet"><a href="#val-logdet" class="anchor"></a><code><span><span class="keyword">val</span> logdet : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>logdet x</code> computes the log of the determinant of a square matrix <code>x</code>. It is equivalent to <code>log (det x)</code> but may provide more accuracy and efficiency.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rank"><a href="#val-rank" class="anchor"></a><code><span><span class="keyword">val</span> rank : <span>?tol:float <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>rank x</code> calculates the rank of a rectangular matrix <code>x</code> of shape <code>m x n</code>. The function does so by counting the number of singular values of <code>x</code> which are beyond a pre-defined threshold <code>tol</code>. By default, <code>tol = max(m,n) * eps</code> where <code>eps = 1e-10</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-norm"><a href="#val-norm" class="anchor"></a><code><span><span class="keyword">val</span> norm : <span>?p:float <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>norm ~p x</code> computes the matrix p-norm of the passed in matrix <code>x</code>.</p><p>Parameters: * <code>p</code> is the order of norm, the default value is 2. * <code>x</code> is the input matrix.</p><p>Returns: * If <code>p = 1</code>, then returns the maximum absolute column sum of the matrix. * If <code>p = 2</code>, then returns approximately <code>max (svd x)</code>. * If <code>p = infinity</code>, then returns the maximum absolute row sum of the matrix. * If <code>p = -1</code>, then returns the minimum absolute column sum of the matrix. * If <code>p = -2</code>, then returns approximately <code>min (svd x)</code>. * If <code>p = -infinity</code>, then returns the minimum absolute row sum of the matrix.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-vecnorm"><a href="#val-vecnorm" class="anchor"></a><code><span><span class="keyword">val</span> vecnorm : <span>?p:float <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>vecnorm ~p x</code> calculates the generalised vector p-norm, defined as below. If <code>x</code> is a martrix, it will be flatten to a vector first. Different from the function of the same name in :doc:`owl_dense_ndarray_generic`, this function assumes the input is either 1d vector or 2d matrix.</p><p>.. math:: ||v||_p = \Big<code> \sum_{k=0}^{N-1} |v_k|^p \Big</code>^</p><p>/p</p><p>Parameters: * <code>p</code> is the order of norm, the default value is 2. * <code>x</code> is the input vector or matrix.</p><p>Returns: * If <code>p = infinity</code>, then returns :math:`||v||_<code>\infty</code> = \max_i(|v(i)|)`. * If <code>p = -infinity</code>, then returns :math:`||v||_</p><p>\infty</p><p>}</p><p>= \min_i(|v(i)|)`. * If <code>p = 2</code> and <code>x</code> is a matrix, then returns Frobenius norm of <code>x</code>. * Otherwise returns generalised vector p-norm defined above.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cond"><a href="#val-cond" class="anchor"></a><code><span><span class="keyword">val</span> cond : <span>?p:float <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>cond ~p x</code> computes the p-norm condition number of matrix <code>x</code>.</p><p><code>cond ~p:1. x</code> returns the 1-norm condition number;</p><p><code>cond ~p:2. x</code> or <code>cond x</code> returns the 2-norm condition number.</p><p><code>cond ~p:infinity x</code> returns the infinity norm condition number.</p><p>The default value of <code>p</code> is <code>2.</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rcond"><a href="#val-rcond" class="anchor"></a><code><span><span class="keyword">val</span> rcond : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>rcond x</code> returns an estimate for the reciprocal condition of <code>x</code> in 1-norm. If <code>x</code> is well conditioned, the returned result is near <code>1.0</code>. If <code>x</code> is badly conditioned, the result is near <code>0.</code></p></div></div><h6 id="check-matrix-types"><a href="#check-matrix-types" class="anchor"></a>Check matrix types</h6><div class="odoc-spec"><div class="spec value anchored" id="val-is_square"><a href="#val-is_square" class="anchor"></a><code><span><span class="keyword">val</span> is_square : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_square x</code> returns <code>true</code> if <code>x</code> is a square matrix otherwise <code>false</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_triu"><a href="#val-is_triu" class="anchor"></a><code><span><span class="keyword">val</span> is_triu : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_triu x</code> returns <code>true</code> if <code>x</code> is upper triangular otherwise <code>false</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_tril"><a href="#val-is_tril" class="anchor"></a><code><span><span class="keyword">val</span> is_tril : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_tril x</code> returns <code>true</code> if <code>x</code> is lower triangular otherwise <code>false</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_symmetric"><a href="#val-is_symmetric" class="anchor"></a><code><span><span class="keyword">val</span> is_symmetric : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_symmetric x</code> returns <code>true</code> if <code>x</code> is symmetric otherwise <code>false</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_hermitian"><a href="#val-is_hermitian" class="anchor"></a><code><span><span class="keyword">val</span> is_hermitian : <span><span><span>(<span class="xref-unresolved">Stdlib</span>.Complex.t, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_hermitian x</code> returns <code>true</code> if <code>x</code> is hermitian otherwise <code>false</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_diag"><a href="#val-is_diag" class="anchor"></a><code><span><span class="keyword">val</span> is_diag : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_diag x</code> returns <code>true</code> if <code>x</code> is diagonal otherwise <code>false</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_posdef"><a href="#val-is_posdef" class="anchor"></a><code><span><span class="keyword">val</span> is_posdef : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_posdef x</code> checks whether <code>x</code> is a positive semi-definite matrix.</p></div></div><h6 id="factorisation"><a href="#factorisation" class="anchor"></a>Factorisation</h6><div class="odoc-spec"><div class="spec value anchored" id="val-lu"><a href="#val-lu" class="anchor"></a><code><span><span class="keyword">val</span> lu : 
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span>(int32, <span class="xref-unresolved">Stdlib</span>.Bigarray.int32_elt)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>lu x -&gt; (l, u, ipiv)</code> calculates LU decomposition of <code>x</code>. The pivoting is used by default.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lq"><a href="#val-lq" class="anchor"></a><code><span><span class="keyword">val</span> lq : <span>?thin:bool <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>lq x -&gt; (l, q)</code> calculates the LQ decomposition of <code>x</code>. By default, the reduced LQ decomposition is performed. But you can get full <code>Q</code> by setting parameter <code>thin = false</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-qr"><a href="#val-qr" class="anchor"></a><code><span><span class="keyword">val</span> qr : 
  <span>?thin:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?pivot:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span>(int32, <span class="xref-unresolved">Stdlib</span>.Bigarray.int32_elt)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>qr x</code> calculates QR decomposition for an <code>m</code> by <code>n</code> matrix <code>x</code> as <code>x = Q R</code>. <code>Q</code> is an <code>m</code> by <code>n</code> matrix (where <code>Q^T Q = I</code>) and <code>R</code> is an <code>n</code> by <code>n</code> upper-triangular matrix.</p><p>The function returns a 3-tuple, the first two are <code>q</code> and <code>r</code>, and the third is the permutation vector of columns. The default value of <code>pivot</code> is <code>false</code>, setting <code>pivot = true</code> lets <code>qr</code> performs pivoted factorisation. Note that the returned indices are not adjusted to 0-based C layout.</p><p>By default, <code>qr</code> performs a reduced QR factorisation, full factorisation can be enabled by setting <code>thin</code> parameter to <code>false</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-chol"><a href="#val-chol" class="anchor"></a><code><span><span class="keyword">val</span> chol : <span>?upper:bool <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>chol x -&gt; u</code> calculates the Cholesky factorisation of a positive definite matrix <code>x</code> such that <code>x = u' *@ u</code>. By default, the upper triangular matrix is returned. The lower triangular part can be obtained by setting the parameter <code>upper = false</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-svd"><a href="#val-svd" class="anchor"></a><code><span><span class="keyword">val</span> svd : <span>?thin:bool <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>svd x -&gt; (u, s, vt)</code> calculates the singular value decomposition of <code>x</code>, and returns a 3-tuple <code>(u,s,vt)</code>. By default, a reduced svd is performed: E.g., for a <code>m x n</code> matrix <code>x</code> wherein <code>m &lt;= n</code>, <code>u</code> is returned as an <code>m</code> by <code>m</code> orthogonal matrix, <code>s</code> an <code>1</code> by <code>m</code> row vector of singular values, and <code>vt</code> is the transpose of an <code>n</code> by <code>m</code> orthogonal rectangular matrix.</p><p>The full svd can be performed by setting <code>thin = false</code>. Note that for complex numbers, the type of returned singular values are also complex, the imaginary part is zero.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-svdvals"><a href="#val-svdvals" class="anchor"></a><code><span><span class="keyword">val</span> svdvals : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>svdvals x -&gt; s</code> performs the singular value decomposition of <code>x</code> like <code>svd x</code>, but the function only returns the singular values without <code>u</code> and <code>vt</code>. Note that for complex numbers, the return is also complex type.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-gsvd"><a href="#val-gsvd" class="anchor"></a><code><span><span class="keyword">val</span> gsvd : 
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>gsvd x y -&gt; (u, v, q, d1, d2, r)</code> computes the generalised singular value decomposition of a pair of general rectangular matrices <code>x</code> and <code>y</code>. <code>d1</code> and <code>d2</code> contain the generalised singular value pairs of <code>x</code> and <code>y</code>. The shape of <code>x</code> is <code>m x n</code> and the shape of <code>y</code> is <code>p x n</code>.</p><p>.. code-block:: ocaml</p><p>let x = Mat.uniform 5 5;; let y = Mat.uniform 2 5;; let u, v, q, d1, d2, r = Linalg.gsvd x y;; Mat.(u *@ d1 *@ r *@ transpose q =~ x);; Mat.(v *@ d2 *@ r *@ transpose q =~ y);;</p><p>Please refer to: `Intel MKL Reference &lt;https://software.intel.com/en-us/mkl-developer-reference-c-ggsvd3&gt;`_</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-gsvdvals"><a href="#val-gsvdvals" class="anchor"></a><code><span><span class="keyword">val</span> gsvdvals : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>gsvdvals x y</code> is similar to <code>gsvd x y</code> but only returns the singular values of the generalised singular value decomposition of <code>x</code> and <code>y</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-schur"><a href="#val-schur" class="anchor"></a><code><span><span class="keyword">val</span> schur : 
  <span>otyp:<span><span>(<span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <span class="xref-unresolved">Stdlib</span>.Bigarray.kind</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span>(<span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>schur x -&gt; (t, z, w)</code> calculates Schur factorisation of <code>x</code> in the following form.</p><p>.. math:: X = Z T Z^H</p><p>Parameters: * <code>otyp</code>: the complex type of eigen values. * <code>x</code>: the <code>n x n</code> square matrix.</p><p>Returns: * <code>t</code> is (quasi) triangular Schur factor. * <code>z</code> is orthogonal/unitary Schur vectors. The eigen values are not sorted, they have the same order as that they appear on the diagonal of the output of Schur form <code>t</code>. * <code>w</code> contains the eigen values of <code>x</code>. <code>otyp</code> is used to specify the type of <code>w</code>. It needs to be consistent with input type. E.g., if the input <code>x</code> is <code>float32</code> then <code>otyp</code> must be <code>complex32</code>. However, if you use S, D, C, Z module, then you do not need to worry about <code>otyp</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-schur_tz"><a href="#val-schur_tz" class="anchor"></a><code><span><span class="keyword">val</span> schur_tz : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>schur_tz x</code> is similar to <code>schur</code> but only returns <code>(t, z)</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ordschur"><a href="#val-ordschur" class="anchor"></a><code><span><span class="keyword">val</span> ordschur : 
  <span>otyp:<span><span>(<span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <span class="xref-unresolved">Stdlib</span>.Bigarray.kind</span> <span class="arrow">&#45;&gt;</span></span>
  <span>select:<span><span>(int32, <span class="xref-unresolved">Stdlib</span>.Bigarray.int32_elt)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span>(<span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>ordschur ~select t z -&gt; (r, p)</code> reorders <code>t</code> and <code>z</code> returned by Schur factorization <code>schur x -&gt; (t, z)</code> according <code>select</code> such that</p><p>.. math:: X = P R P^H</p><p>Parameters: * <code>otyp</code>: the complex type of eigen values * <code>select</code> the logical vector to select eigenvalues, refer to <code>select_ev</code>. * <code>t</code>: the Schur matrix returned by <code>schur x</code>. * <code>z</code>: the unitary matrix <code>z</code> returned by <code>schur x</code>.</p><p>Returns: * <code>r</code>: reordered Schur matrix <code>t</code>. * <code>p</code>: reordered orthogonal matrix <code>z</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-qz"><a href="#val-qz" class="anchor"></a><code><span><span class="keyword">val</span> qz : 
  <span>otyp:<span><span>(<span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <span class="xref-unresolved">Stdlib</span>.Bigarray.kind</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span>(<span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>qz x -&gt; (s, t, q, z, w)</code> calculates generalised Schur factorisation of <code>x</code> in the following form. It is also known as QZ decomposition.</p><p>.. math:: X = Q S Z^H Y = Z T Z^H</p><p>Parameters: * <code>otyp</code>: the complex type of eigen values. * <code>x</code>: the <code>n x n</code> square matrix. * <code>y</code>: the <code>n x n</code> square matrix.</p><p>Returns: * <code>s</code>: the upper quasitriangular matrices S. * <code>t</code>: the upper quasitriangular matrices T. * <code>q</code>: the unitary matrices Q. * <code>z</code>: the unitary matrices Z. * <code>w</code>: the generalised eigenvalue for a pair of matrices (X,Y).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ordqz"><a href="#val-ordqz" class="anchor"></a><code><span><span class="keyword">val</span> ordqz : 
  <span>otyp:<span><span>(<span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <span class="xref-unresolved">Stdlib</span>.Bigarray.kind</span> <span class="arrow">&#45;&gt;</span></span>
  <span>select:<span><span>(int32, <span class="xref-unresolved">Stdlib</span>.Bigarray.int32_elt)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span>(<span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>ordqz ~select a b q z</code> reorders the generalised Schur decomposition of a pair of matrices (X,Y) so that a selected cluster of eigenvalues appears in the leading diagonal blocks of (X,Y).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-qzvals"><a href="#val-qzvals" class="anchor"></a><code><span><span class="keyword">val</span> qzvals : 
  <span>otyp:<span><span>(<span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <span class="xref-unresolved">Stdlib</span>.Bigarray.kind</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>qzvals ~otyp x y</code> is similar to <code>qz ~otyp x y</code> but only returns the generalised eigen values.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-hess"><a href="#val-hess" class="anchor"></a><code><span><span class="keyword">val</span> hess : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>hess x -&gt; (h, q)</code> calculates the Hessenberg form of a given matrix <code>x</code>. Both Hessenberg matrix <code>h</code> and unitary matrix <code>q</code> is returned, such that <code>x = q *@ h *@ (transpose q)</code>.</p><p>.. math:: X = Q H Q^T</p></div></div><h6 id="eigenvalues-&amp;-eigenvectors"><a href="#eigenvalues-&amp;-eigenvectors" class="anchor"></a>Eigenvalues &amp; eigenvectors</h6><div class="odoc-spec"><div class="spec value anchored" id="val-eig"><a href="#val-eig" class="anchor"></a><code><span><span class="keyword">val</span> eig : 
  <span>?permute:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?scale:bool <span class="arrow">&#45;&gt;</span></span>
  <span>otyp:<span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span class="xref-unresolved">Stdlib</span>.Bigarray.kind</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>eig x -&gt; v, w</code> computes the right eigenvectors <code>v</code> and eigenvalues <code>w</code> of an arbitrary square matrix <code>x</code>. The eigenvectors are column vectors in <code>v</code>, their corresponding eigenvalues have the same order in <code>w</code> as that in <code>v</code>.</p><p>Note that <code>otyp</code> specifies the complex type of the output, but you do not need worry about this parameter if you use S, D, C, Z modules in Linalg.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-eigvals"><a href="#val-eigvals" class="anchor"></a><code><span><span class="keyword">val</span> eigvals : 
  <span>?permute:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?scale:bool <span class="arrow">&#45;&gt;</span></span>
  <span>otyp:<span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span class="xref-unresolved">Stdlib</span>.Bigarray.kind</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>eigvals x -&gt; w</code> is similar to <code>eig</code> but only computes the eigenvalues of an arbitrary square matrix <code>x</code>.</p></div></div><h6 id="linear-system-of-equations"><a href="#linear-system-of-equations" class="anchor"></a>Linear system of equations</h6><div class="odoc-spec"><div class="spec value anchored" id="val-null"><a href="#val-null" class="anchor"></a><code><span><span class="keyword">val</span> null : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>null a -&gt; x</code> computes an orthonormal basis <code>x</code> for the null space of <code>a</code> obtained from the singular value decomposition. Namely, <code>a *@ x</code> has negligible elements, <code>M.col_num x</code> is the nullity of <code>a</code>, and <code>transpose x *@ x = I</code>. Namely,</p><p>.. math:: X^T X = I</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-triangular_solve"><a href="#val-triangular_solve" class="anchor"></a><code><span><span class="keyword">val</span> triangular_solve : 
  <span>upper:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?trans:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>triangular_linsolve a b -&gt; x</code> solves a linear system of equations <code>a * x = b</code> where <code>a</code> is either a upper or a lower triangular matrix. This function uses cblas <code>trsm</code> under the hood.</p><p>.. math:: AX = B</p><p>By default, <code>trans = false</code> indicates no transpose. If <code>trans = true</code>, then function will solve <code>A^T * x = b</code> for real matrices; <code>A^H * x = b</code> for complex matrices.</p><p>.. math:: A^H X = B</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-linsolve"><a href="#val-linsolve" class="anchor"></a><code><span><span class="keyword">val</span> linsolve : 
  <span>?trans:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?typ:<span>[ `n <span>| `u</span> <span>| `l</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>linsolve a b -&gt; x</code> solves a linear system of equations <code>a * x = b</code> in the following form. By default, <code>typ=`n</code> and the function use LU factorisation with partial pivoting when <code>a</code> is square and QR factorisation with column pivoting otherwise. The number of rows of <code>a</code> must equal the number of rows of <code>b</code>. If <code>a</code> is a upper(lower) triangular matrix, the function calls the <code>solve_triangular</code> function when <code>typ=`u</code>(<code>typ=`l</code>).</p><p>.. math:: AX = B</p><p>By default, <code>trans = false</code> indicates no transpose. If <code>trans = true</code>, then function will solve <code>A^T * x = b</code> for real matrices; <code>A^H * x = b</code> for complex matrices.</p><p>.. math:: A^H X = B</p><p>The associated operator is <code>/@</code>, so you can simply use <code>a /@ b</code> to solve the linear equation system to get <code>x</code>. Please refer to :doc:`owl_operator`.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-linreg"><a href="#val-linreg" class="anchor"></a><code><span><span class="keyword">val</span> linreg : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> * <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>linreg x y -&gt; (a, b)</code> solves <code>y = a + b*x</code> using Ordinary Least Squares.</p><p>.. math:: Y = A + BX</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sylvester"><a href="#val-sylvester" class="anchor"></a><code><span><span class="keyword">val</span> sylvester : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>sylvester a b c</code> solves a Sylvester equation in the following form. The function calls LAPACKE function <code>trsyl</code> solve the system.</p><p>.. math:: AX + XB = C</p><p>Parameters: * <code>a</code> : <code>m x m</code> matrix A. * <code>b</code> : <code>n x n</code> matrix B. * <code>c</code> : <code>m x n</code> matrix C.</p><p>Returns: * <code>x</code> : <code>m x n</code> matrix X.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lyapunov"><a href="#val-lyapunov" class="anchor"></a><code><span><span class="keyword">val</span> lyapunov : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>lyapunov a q</code> solves a continuous Lyapunov equation in the following form. The function calls LAPACKE function <code>trsyl</code> solve the system. In Matlab, the same function is called <code>lyap</code>.</p><p>.. math:: AX + XA^H = Q</p><p>Parameters: * <code>a</code> : <code>m x m</code> matrix A. * <code>q</code> : <code>n x n</code> matrix Q.</p><p>Returns: * <code>x</code> : <code>m x n</code> matrix X.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-discrete_lyapunov"><a href="#val-discrete_lyapunov" class="anchor"></a><code><span><span class="keyword">val</span> discrete_lyapunov : 
  <span>?solver:<span>[ `default <span>| `bilinear</span> <span>| `direct</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>discrete_lyapunov a q</code> solves a discrete-time Lyapunov equation in the following form.</p><p>.. math:: X - AXA^H = Q</p><p>Parameters: * <code>a</code> : <code>m x m</code> matrix A. * <code>q</code> : <code>n x n</code> matrix Q.</p><p>Returns: * <code>x</code> : <code>m x n</code> matrix X.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-care"><a href="#val-care" class="anchor"></a><code><span><span class="keyword">val</span> care : 
  <span>?diag_r:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(float, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(float, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(float, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(float, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(float, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>care ?diag_r a b q r</code> solves the continuous-time algebraic Riccati equation system in the following form. The algorithm is based on :cite:`laub1979schur`.</p><p>.. math:: A^T X + X A âˆ’ X B R^</p><p>1</p><p>}</p><p>B^T X + Q = 0</p><p>Parameters: * <code>a</code> : real cofficient matrix A. * <code>b</code> : real cofficient matrix B. * <code>q</code> : real cofficient matrix Q. * <code>r</code> : real cofficient matrix R. R must be non-singular. * <code>diag_r</code> : true if R is a diagonal matrix, false by default.</p><p>Returns: * <code>x</code> : a solution matrix X.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-dare"><a href="#val-dare" class="anchor"></a><code><span><span class="keyword">val</span> dare : 
  <span>?diag_r:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(float, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(float, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(float, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(float, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(float, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>dare ?diag_r a b q r</code> solves the discrete-time algebraic Riccati equation system in the following form. The algorithm is based on :cite:`laub1979schur`.</p><p>.. math:: A^T X A - X - (A^T X B) (B^T X B + R)^</p><p>1</p><p>}</p><p>(B^T X A) + Q = 0</p><p>Parameters: * <code>a</code> : real cofficient matrix A. A must be non-singular. * <code>b</code> : real cofficient matrix B. * <code>q</code> : real cofficient matrix Q. * <code>r</code> : real cofficient matrix R. R must be non-singular. * <code>diag_r</code> : true if R is a diagonal matrix, false by default.</p><p>Returns: * <code>x</code> : a symmetric solution matrix X.</p></div></div><h6 id="low-level-factorisation-functions"><a href="#low-level-factorisation-functions" class="anchor"></a>Low-level factorisation functions</h6><div class="odoc-spec"><div class="spec value anchored" id="val-lufact"><a href="#val-lufact" class="anchor"></a><code><span><span class="keyword">val</span> lufact : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span>(int32, <span class="xref-unresolved">Stdlib</span>.Bigarray.int32_elt)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>lufact x -&gt; (a, ipiv)</code> calculates LU factorisation with pivot of a general matrix <code>x</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-qrfact"><a href="#val-qrfact" class="anchor"></a><code><span><span class="keyword">val</span> qrfact : 
  <span>?pivot:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span>(int32, <span class="xref-unresolved">Stdlib</span>.Bigarray.int32_elt)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>qrfact x -&gt; (a, tau, jpvt)</code> calculates QR factorisation of a general matrix <code>x</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bkfact"><a href="#val-bkfact" class="anchor"></a><code><span><span class="keyword">val</span> bkfact : 
  <span>?upper:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?symmetric:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?rook:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span>(int32, <span class="xref-unresolved">Stdlib</span>.Bigarray.int32_elt)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>bk x -&gt; (a, ipiv)</code> calculates Bunch-Kaufman factorisation of <code>x</code>. If <code>symmetric = true</code> then <code>x</code> is symmetric, if <code>symmetric = false</code> then <code>x</code> is hermitian. If <code>rook = true</code> the function performs bounded Bunch-Kaufman (&quot;rook&quot;) diagonal pivoting method, if <code>rook = false</code> then Bunch-Kaufman diagonal pivoting method is used. <code>a</code> contains details of the block-diagonal matrix <code>d</code> and the multipliers used to obtain the factor <code>u</code> (or <code>l</code>).</p><p>The <code>upper</code> indicates whether the upper or lower triangular part of <code>x</code> is stored and how <code>x</code> is factored. If <code>upper = true</code> then upper triangular part is stored: <code>x = u*d*u'</code> else <code>x = l*d*l'</code>.</p><p>For <code>ipiv</code>, it indicates the details of the interchanges and the block structure of <code>d</code>. Please refer to the function <code>sytrf</code>, <code>hetrf</code> in MKL documentation for more details.</p></div></div><h6 id="matrix-functions"><a href="#matrix-functions" class="anchor"></a>Matrix functions</h6><div class="odoc-spec"><div class="spec value anchored" id="val-mpow"><a href="#val-mpow" class="anchor"></a><code><span><span class="keyword">val</span> mpow : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>mpow x r</code> returns the dot product of square matrix <code>x</code> with itself <code>r</code> times, and more generally raises the matrix to the <code>r</code>th power. <code>r</code> is a float that must be equal to an integer; it can be be negative, zero, or positive. Non-integer exponents are not yet implemented. (If <code>r</code> is negative, <code>mpow</code> calls <code>inv</code>, and warnings in documentation for <code>inv</code> apply.)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-expm"><a href="#val-expm" class="anchor"></a><code><span><span class="keyword">val</span> expm : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>expm x</code> computes the matrix exponential of <code>x</code> defined by</p><p>.. math:: e^x = \sum_<code>k=0</code>^<code>\infty</code> \frac</p><p></p><p><code>k!</code> x^k</p><p>The function implements the scaling and squaring algorithm which uses PadÃ© approximation to compute the matrix exponential :cite:`al2009new`.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sinm"><a href="#val-sinm" class="anchor"></a><code><span><span class="keyword">val</span> sinm : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>sinm x</code> computes the matrix sine of input <code>x</code>. The function uses <code>expm</code> to compute the matrix exponentials.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cosm"><a href="#val-cosm" class="anchor"></a><code><span><span class="keyword">val</span> cosm : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>cosm x</code> computes the matrix cosine of input <code>x</code>. The function uses <code>expm</code> to compute the matrix exponentials.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tanm"><a href="#val-tanm" class="anchor"></a><code><span><span class="keyword">val</span> tanm : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>tanm x</code> computes the matrix tangent of input <code>x</code>. The function uses <code>expm</code> to compute the matrix exponentials.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sincosm"><a href="#val-sincosm" class="anchor"></a><code><span><span class="keyword">val</span> sincosm : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>sincosm x</code> returns both matrix sine and cosine of <code>x</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sinhm"><a href="#val-sinhm" class="anchor"></a><code><span><span class="keyword">val</span> sinhm : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>sinhm x</code> computes the hyperbolic matrix sine of input <code>x</code>. The function uses <code>expm</code> to compute the matrix exponentials.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-coshm"><a href="#val-coshm" class="anchor"></a><code><span><span class="keyword">val</span> coshm : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>coshm x</code> computes the hyperbolic matrix cosine of input <code>x</code>. The function uses <code>expm</code> to compute the matrix exponentials.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tanhm"><a href="#val-tanhm" class="anchor"></a><code><span><span class="keyword">val</span> tanhm : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>tanhm x</code> computes the hyperbolic matrix tangent of input <code>x</code>. The function uses <code>expm</code> to compute the matrix exponentials.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sinhcoshm"><a href="#val-sinhcoshm" class="anchor"></a><code><span><span class="keyword">val</span> sinhcoshm : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> * <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>sinhcoshm x</code> returns both hyperbolic matrix sine and cosine of <code>x</code>.</p></div></div><h6 id="helper-functions"><a href="#helper-functions" class="anchor"></a>Helper functions</h6><div class="odoc-spec"><div class="spec value anchored" id="val-select_ev"><a href="#val-select_ev" class="anchor"></a><code><span><span class="keyword">val</span> select_ev : 
  <span><span>[ `LHP <span>| `RHP</span> <span>| `UDI</span> <span>| `UDO</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(int32, <span class="xref-unresolved">Stdlib</span>.Bigarray.int32_elt)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>select_ev keyword ev</code> generates a logical vector (of same shape as <code>ev</code>) from eigen values <code>ev</code> according to the passed in keywards.</p><ul><li><code>LHP</code>: Left-half plane :math:`(real(e) &lt; 0)`.</li><li><code>RHP</code>: Left-half plane :math:`(real(e) \ge 0)`.</li><li><code>UDI</code>: Left-half plane :math:`(abs(e) &lt; 1)`.</li><li><code>UDO</code>: Left-half plane :math:`(abs(e) \ge 0)`.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-peakflops"><a href="#val-peakflops" class="anchor"></a><code><span><span class="keyword">val</span> peakflops : <span>?n:int <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>peakflops ()</code> returns the peak number of float point operations using <code>Owl_cblas_basic.dgemm</code> function. The default matrix size is <code>2000 x 2000</code>, but you can change this by setting <code>n</code> to other numbers as you like.</p></div></div></div></body></html>