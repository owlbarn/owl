<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Generic (owl.Owl_linalg.Generic)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../index.html">owl</a> &#x00BB; <a href="../index.html">Owl_linalg</a> &#x00BB; Generic</nav><header class="odoc-preamble"><h1>Module <code><span>Owl_linalg.Generic</span></code></h1></header><div class="odoc-content"><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <span class="keyword">struct</span> <span class="keyword">include</span> <a href="../../Owl_linalg_generic/index.html">Owl_linalg_generic</a> <span class="keyword">end</span></span></code></summary><p>The module includes a set of advanced linear algebra operations such as singular value decomposition, and etc.</p><p>Currently, Linalg module supports dense matrix of four different number types, including ``float32``, ``float64``, ``complex32``, and ``complex64``. The support for sparse matrices will be provided in future.</p><h6 id="type-definition"><a href="#type-definition" class="anchor"></a>Type definition</h6><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b) t</span></span><span> = <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="../../Owl_dense_matrix_generic/index.html#type-t">Owl_dense_matrix_generic.t</a></span></span></code></div><div class="spec-doc"><p>Matrix type, a special case of N-dimensional array.</p></div></div><h6 id="basic-functions"><a href="#basic-functions" class="anchor"></a>Basic functions</h6><div class="odoc-spec"><div class="spec value" id="val-inv" class="anchored"><a href="#val-inv" class="anchor"></a><code><span><span class="keyword">val</span> inv : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``inv x`` calculates the inverse of an invertible square matrix ``x`` such that ``x *@ x = I`` wherein ``I`` is an identity matrix. (If ``x`` is singular, ``inv`` will return a useless result.)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pinv" class="anchored"><a href="#val-pinv" class="anchor"></a><code><span><span class="keyword">val</span> pinv : <span>?tol:float <span class="arrow">&#45;&gt;</span></span> <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``pinv x`` computes Moore-Penrose pseudoinverse of matrix ``x``. ``tol`` specifies the tolerance, the absolute value of the elements smaller than ``tol`` will be set to zeros.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-det" class="anchored"><a href="#val-det" class="anchor"></a><code><span><span class="keyword">val</span> det : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>``det x`` computes the determinant of a square matrix ``x``.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-logdet" class="anchored"><a href="#val-logdet" class="anchor"></a><code><span><span class="keyword">val</span> logdet : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>``logdet x`` computes the log of the determinant of a square matrix ``x``. It is equivalent to ``log (det x)`` but may provide more accuracy and efficiency.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rank" class="anchored"><a href="#val-rank" class="anchor"></a><code><span><span class="keyword">val</span> rank : <span>?tol:float <span class="arrow">&#45;&gt;</span></span> <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>``rank x`` calculates the rank of a rectangular matrix ``x`` of shape ``m x n``. The function does so by counting the number of singular values of ``x`` which are beyond a pre-defined threshold ``tol``. By default, ``tol = max(m,n) * eps`` where ``eps = 1e-10``.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-norm" class="anchored"><a href="#val-norm" class="anchor"></a><code><span><span class="keyword">val</span> norm : <span>?p:float <span class="arrow">&#45;&gt;</span></span> <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>``norm ~p x`` computes the matrix p-norm of the passed in matrix ``x``.</p><p>Parameters: * ``p`` is the order of norm, the default value is 2. * ``x`` is the input matrix.</p><p>Returns: * If ``p = 1``, then returns the maximum absolute column sum of the matrix. * If ``p = 2``, then returns approximately ``max (svd x)``. * If ``p = infinity``, then returns the maximum absolute row sum of the matrix. * If ``p = -1``, then returns the minimum absolute column sum of the matrix. * If ``p = -2``, then returns approximately ``min (svd x)``. * If ``p = -infinity``, then returns the minimum absolute row sum of the matrix.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-vecnorm" class="anchored"><a href="#val-vecnorm" class="anchor"></a><code><span><span class="keyword">val</span> vecnorm : <span>?p:float <span class="arrow">&#45;&gt;</span></span> <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>``vecnorm ~p x`` calculates the generalised vector p-norm, defined as below. If ``x`` is a martrix, it will be flatten to a vector first. Different from the function of the same name in :doc:`owl_dense_ndarray_generic`, this function assumes the input is either 1d vector or 2d matrix.</p><p>.. math:: ||v||_p = \Big<code> \sum_{k=0}^{N-1} |v_k|^p \Big</code>^</p><p>/p</p><p>Parameters: * ``p`` is the order of norm, the default value is 2. * ``x`` is the input vector or matrix.</p><p>Returns: * If ``p = infinity``, then returns :math:`||v||_<code>\infty</code> = \max_i(|v(i)|)`. * If ``p = -infinity``, then returns :math:`||v||_</p><p>\infty</p><p>}</p><p>= \min_i(|v(i)|)`. * If ``p = 2`` and ``x`` is a matrix, then returns Frobenius norm of ``x``. * Otherwise returns generalised vector p-norm defined above.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cond" class="anchored"><a href="#val-cond" class="anchor"></a><code><span><span class="keyword">val</span> cond : <span>?p:float <span class="arrow">&#45;&gt;</span></span> <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>``cond ~p x`` computes the p-norm condition number of matrix ``x``.</p><p>``cond ~p:1. x`` returns the 1-norm condition number;</p><p>``cond ~p:2. x`` or ``cond x`` returns the 2-norm condition number.</p><p>``cond ~p:infinity x`` returns the infinity norm condition number.</p><p>The default value of ``p`` is ``2.``</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rcond" class="anchored"><a href="#val-rcond" class="anchor"></a><code><span><span class="keyword">val</span> rcond : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>``rcond x`` returns an estimate for the reciprocal condition of ``x`` in 1-norm. If ``x`` is well conditioned, the returned result is near ``1.0``. If ``x`` is badly conditioned, the result is near ``0.``</p></div></div><h6 id="check-matrix-types"><a href="#check-matrix-types" class="anchor"></a>Check matrix types</h6><div class="odoc-spec"><div class="spec value" id="val-is_square" class="anchored"><a href="#val-is_square" class="anchor"></a><code><span><span class="keyword">val</span> is_square : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>``is_square x`` returns ``true`` if ``x`` is a square matrix otherwise ``false``.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_triu" class="anchored"><a href="#val-is_triu" class="anchor"></a><code><span><span class="keyword">val</span> is_triu : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>``is_triu x`` returns ``true`` if ``x`` is upper triangular otherwise ``false``.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_tril" class="anchored"><a href="#val-is_tril" class="anchor"></a><code><span><span class="keyword">val</span> is_tril : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>``is_tril x`` returns ``true`` if ``x`` is lower triangular otherwise ``false``.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_symmetric" class="anchored"><a href="#val-is_symmetric" class="anchor"></a><code><span><span class="keyword">val</span> is_symmetric : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>``is_symmetric x`` returns ``true`` if ``x`` is symmetric otherwise ``false``.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_hermitian" class="anchored"><a href="#val-is_hermitian" class="anchor"></a><code><span><span class="keyword">val</span> is_hermitian : <span><span><span>( <span class="xref-unresolved">Stdlib</span>.Complex.t, <span class="type-var">'a</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>``is_hermitian x`` returns ``true`` if ``x`` is hermitian otherwise ``false``.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_diag" class="anchored"><a href="#val-is_diag" class="anchor"></a><code><span><span class="keyword">val</span> is_diag : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>``is_diag x`` returns ``true`` if ``x`` is diagonal otherwise ``false``.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_posdef" class="anchored"><a href="#val-is_posdef" class="anchor"></a><code><span><span class="keyword">val</span> is_posdef : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>``is_posdef x`` checks whether ``x`` is a positive semi-definite matrix.</p></div></div><h6 id="factorisation"><a href="#factorisation" class="anchor"></a>Factorisation</h6><div class="odoc-spec"><div class="spec value" id="val-lu" class="anchored"><a href="#val-lu" class="anchor"></a><code><span><span class="keyword">val</span> lu : 
  <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> * <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> * <span><span>( int32, <span class="xref-unresolved">Stdlib</span>.Bigarray.int32_elt )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``lu x -&gt; (l, u, ipiv)`` calculates LU decomposition of ``x``. The pivoting is used by default.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lq" class="anchored"><a href="#val-lq" class="anchor"></a><code><span><span class="keyword">val</span> lq : <span>?thin:bool <span class="arrow">&#45;&gt;</span></span> <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> * <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``lq x -&gt; (l, q)`` calculates the LQ decomposition of ``x``. By default, the reduced LQ decomposition is performed. But you can get full ``Q`` by setting parameter ``thin = false``.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-qr" class="anchored"><a href="#val-qr" class="anchor"></a><code><span><span class="keyword">val</span> qr : 
  <span>?thin:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?pivot:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> * <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> * <span><span>( int32, <span class="xref-unresolved">Stdlib</span>.Bigarray.int32_elt )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``qr x`` calculates QR decomposition for an ``m`` by ``n`` matrix ``x`` as ``x = Q R``. ``Q`` is an ``m`` by ``n`` matrix (where ``Q^T Q = I``) and ``R`` is an ``n`` by ``n`` upper-triangular matrix.</p><p>The function returns a 3-tuple, the first two are ``q`` and ``r``, and the third is the permutation vector of columns. The default value of ``pivot`` is ``false``, setting ``pivot = true`` lets ``qr`` performs pivoted factorisation. Note that the returned indices are not adjusted to 0-based C layout.</p><p>By default, ``qr`` performs a reduced QR factorisation, full factorisation can be enabled by setting ``thin`` parameter to ``false``.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-chol" class="anchored"><a href="#val-chol" class="anchor"></a><code><span><span class="keyword">val</span> chol : <span>?upper:bool <span class="arrow">&#45;&gt;</span></span> <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``chol x -&gt; u`` calculates the Cholesky factorisation of a positive definite matrix ``x`` such that ``x = u' *@ u``. By default, the upper triangular matrix is returned. The lower triangular part can be obtained by setting the parameter ``upper = false``.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-svd" class="anchored"><a href="#val-svd" class="anchor"></a><code><span><span class="keyword">val</span> svd : 
  <span>?thin:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> * <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> * <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``svd x -&gt; (u, s, vt)`` calculates the singular value decomposition of ``x``, and returns a 3-tuple ``(u,s,vt)``. By default, a reduced svd is performed: E.g., for a ``m x n`` matrix ``x`` wherein ``m &lt;= n``, ``u`` is returned as an ``m`` by ``m`` orthogonal matrix, ``s`` an ``1`` by ``m`` row vector of singular values, and ``vt`` is the transpose of an ``n`` by ``m`` orthogonal rectangular matrix.</p><p>The full svd can be performed by setting ``thin = false``. Note that for complex numbers, the type of returned singular values are also complex, the imaginary part is zero.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-svdvals" class="anchored"><a href="#val-svdvals" class="anchor"></a><code><span><span class="keyword">val</span> svdvals : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``svdvals x -&gt; s`` performs the singular value decomposition of ``x`` like ``svd x``, but the function only returns the singular values without ``u`` and ``vt``. Note that for complex numbers, the return is also complex type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-gsvd" class="anchored"><a href="#val-gsvd" class="anchor"></a><code><span><span class="keyword">val</span> gsvd : 
  <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span>
  * <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span>
  * <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span>
  * <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span>
  * <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span>
  * <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``gsvd x y -&gt; (u, v, q, d1, d2, r)`` computes the generalised singular value decomposition of a pair of general rectangular matrices ``x`` and ``y``. ``d1`` and ``d2`` contain the generalised singular value pairs of ``x`` and ``y``. The shape of ``x`` is ``m x n`` and the shape of ``y`` is ``p x n``.</p><p>.. code-block:: ocaml</p><p>let x = Mat.uniform 5 5;; let y = Mat.uniform 2 5;; let u, v, q, d1, d2, r = Linalg.gsvd x y;; Mat.(u *@ d1 *@ r *@ transpose q =~ x);; Mat.(v *@ d2 *@ r *@ transpose q =~ y);;</p><p>Please refer to: `Intel MKL Reference &lt;https://software.intel.com/en-us/mkl-developer-reference-c-ggsvd3&gt;`_</p></div></div><div class="odoc-spec"><div class="spec value" id="val-gsvdvals" class="anchored"><a href="#val-gsvdvals" class="anchor"></a><code><span><span class="keyword">val</span> gsvdvals : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``gsvdvals x y`` is similar to ``gsvd x y`` but only returns the singular values of the generalised singular value decomposition of ``x`` and ``y``.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-schur" class="anchored"><a href="#val-schur" class="anchor"></a><code><span><span class="keyword">val</span> schur : 
  <span>otyp:<span><span>( <span class="type-var">'c</span>, <span class="type-var">'d</span> )</span> <span class="xref-unresolved">Stdlib</span>.Bigarray.kind</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> * <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> * <span><span>( <span class="type-var">'c</span>, <span class="type-var">'d</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``schur x -&gt; (t, z, w)`` calculates Schur factorisation of ``x`` in the following form.</p><p>.. math:: X = Z T Z^H</p><p>Parameters: * ``otyp``: the complex type of eigen values. * ``x``: the ``n x n`` square matrix.</p><p>Returns: * ``t`` is (quasi) triangular Schur factor. * ``z`` is orthogonal/unitary Schur vectors. The eigen values are not sorted, they have the same order as that they appear on the diagonal of the output of Schur form ``t``. * ``w`` contains the eigen values of ``x``. ``otyp`` is used to specify the type of ``w``. It needs to be consistent with input type. E.g., if the input ``x`` is ``float32`` then ``otyp`` must be ``complex32``. However, if you use S, D, C, Z module, then you do not need to worry about ``otyp``.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-schur_tz" class="anchored"><a href="#val-schur_tz" class="anchor"></a><code><span><span class="keyword">val</span> schur_tz : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> * <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``schur_tz x`` is similar to ``schur`` but only returns ``(t, z)``.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ordschur" class="anchored"><a href="#val-ordschur" class="anchor"></a><code><span><span class="keyword">val</span> ordschur : 
  <span>otyp:<span><span>( <span class="type-var">'c</span>, <span class="type-var">'d</span> )</span> <span class="xref-unresolved">Stdlib</span>.Bigarray.kind</span> <span class="arrow">&#45;&gt;</span></span>
  <span>select:<span><span>( int32, <span class="xref-unresolved">Stdlib</span>.Bigarray.int32_elt )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> * <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> * <span><span>( <span class="type-var">'c</span>, <span class="type-var">'d</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``ordschur ~select t z -&gt; (r, p)`` reorders ``t`` and ``z`` returned by Schur factorization ``schur x -&gt; (t, z)`` according ``select`` such that</p><p>.. math:: X = P R P^H</p><p>Parameters: * ``otyp``: the complex type of eigen values * ``select`` the logical vector to select eigenvalues, refer to ``select_ev``. * ``t``: the Schur matrix returned by ``schur x``. * ``z``: the unitary matrix ``z`` returned by ``schur x``.</p><p>Returns: * ``r``: reordered Schur matrix ``t``. * ``p``: reordered orthogonal matrix ``z``.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-qz" class="anchored"><a href="#val-qz" class="anchor"></a><code><span><span class="keyword">val</span> qz : 
  <span>otyp:<span><span>( <span class="type-var">'c</span>, <span class="type-var">'d</span> )</span> <span class="xref-unresolved">Stdlib</span>.Bigarray.kind</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> * <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> * <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> * <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> * <span><span>( <span class="type-var">'c</span>, <span class="type-var">'d</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``qz x -&gt; (s, t, q, z, w)`` calculates generalised Schur factorisation of ``x`` in the following form. It is also known as QZ decomposition.</p><p>.. math:: X = Q S Z^H Y = Z T Z^H</p><p>Parameters: * ``otyp``: the complex type of eigen values. * ``x``: the ``n x n`` square matrix. * ``y``: the ``n x n`` square matrix.</p><p>Returns: * ``s``: the upper quasitriangular matrices S. * ``t``: the upper quasitriangular matrices T. * ``q``: the unitary matrices Q. * ``z``: the unitary matrices Z. * ``w``: the generalised eigenvalue for a pair of matrices (X,Y).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ordqz" class="anchored"><a href="#val-ordqz" class="anchor"></a><code><span><span class="keyword">val</span> ordqz : 
  <span>otyp:<span><span>( <span class="type-var">'c</span>, <span class="type-var">'d</span> )</span> <span class="xref-unresolved">Stdlib</span>.Bigarray.kind</span> <span class="arrow">&#45;&gt;</span></span>
  <span>select:<span><span>( int32, <span class="xref-unresolved">Stdlib</span>.Bigarray.int32_elt )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> * <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> * <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> * <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> * <span><span>( <span class="type-var">'c</span>, <span class="type-var">'d</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``ordqz ~select a b q z`` reorders the generalised Schur decomposition of a pair of matrices (X,Y) so that a selected cluster of eigenvalues appears in the leading diagonal blocks of (X,Y).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-qzvals" class="anchored"><a href="#val-qzvals" class="anchor"></a><code><span><span class="keyword">val</span> qzvals : 
  <span>otyp:<span><span>( <span class="type-var">'c</span>, <span class="type-var">'d</span> )</span> <span class="xref-unresolved">Stdlib</span>.Bigarray.kind</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span class="type-var">'c</span>, <span class="type-var">'d</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``qzvals ~otyp x y`` is similar to ``qz ~otyp x y`` but only returns the generalised eigen values.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-hess" class="anchored"><a href="#val-hess" class="anchor"></a><code><span><span class="keyword">val</span> hess : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> * <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``hess x -&gt; (h, q)`` calculates the Hessenberg form of a given matrix ``x``. Both Hessenberg matrix ``h`` and unitary matrix ``q`` is returned, such that ``x = q *@ h *@ (transpose q)``.</p><p>.. math:: X = Q H Q^T</p></div></div><h6 id="eigenvalues-&amp;-eigenvectors"><a href="#eigenvalues-&amp;-eigenvectors" class="anchor"></a>Eigenvalues &amp; eigenvectors</h6><div class="odoc-spec"><div class="spec value" id="val-eig" class="anchored"><a href="#val-eig" class="anchor"></a><code><span><span class="keyword">val</span> eig : 
  <span>?permute:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?scale:bool <span class="arrow">&#45;&gt;</span></span>
  <span>otyp:<span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <span class="xref-unresolved">Stdlib</span>.Bigarray.kind</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span class="type-var">'c</span>, <span class="type-var">'d</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> * <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``eig x -&gt; v, w`` computes the right eigenvectors ``v`` and eigenvalues ``w`` of an arbitrary square matrix ``x``. The eigenvectors are column vectors in ``v``, their corresponding eigenvalues have the same order in ``w`` as that in ``v``.</p><p>Note that ``otyp`` specifies the complex type of the output, but you do not need worry about this parameter if you use S, D, C, Z modules in Linalg.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-eigvals" class="anchored"><a href="#val-eigvals" class="anchor"></a><code><span><span class="keyword">val</span> eigvals : 
  <span>?permute:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?scale:bool <span class="arrow">&#45;&gt;</span></span>
  <span>otyp:<span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <span class="xref-unresolved">Stdlib</span>.Bigarray.kind</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span class="type-var">'c</span>, <span class="type-var">'d</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``eigvals x -&gt; w`` is similar to ``eig`` but only computes the eigenvalues of an arbitrary square matrix ``x``.</p></div></div><h6 id="linear-system-of-equations"><a href="#linear-system-of-equations" class="anchor"></a>Linear system of equations</h6><div class="odoc-spec"><div class="spec value" id="val-null" class="anchored"><a href="#val-null" class="anchor"></a><code><span><span class="keyword">val</span> null : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``null a -&gt; x`` computes an orthonormal basis ``x`` for the null space of ``a`` obtained from the singular value decomposition. Namely, ``a *@ x`` has negligible elements, ``M.col_num x`` is the nullity of ``a``, and ``transpose x *@ x = I``. Namely,</p><p>.. math:: X^T X = I</p></div></div><div class="odoc-spec"><div class="spec value" id="val-triangular_solve" class="anchored"><a href="#val-triangular_solve" class="anchor"></a><code><span><span class="keyword">val</span> triangular_solve : 
  <span>upper:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?trans:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``triangular_linsolve a b -&gt; x`` solves a linear system of equations ``a * x = b`` where ``a`` is either a upper or a lower triangular matrix. This function uses cblas ``trsm`` under the hood.</p><p>.. math:: AX = B</p><p>By default, ``trans = false`` indicates no transpose. If ``trans = true``, then function will solve ``A^T * x = b`` for real matrices; ``A^H * x = b`` for complex matrices.</p><p>.. math:: A^H X = B</p></div></div><div class="odoc-spec"><div class="spec value" id="val-linsolve" class="anchored"><a href="#val-linsolve" class="anchor"></a><code><span><span class="keyword">val</span> linsolve : 
  <span>?trans:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?typ:<span>[ `n <span>| `u</span> <span>| `l</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``linsolve a b -&gt; x`` solves a linear system of equations ``a * x = b`` in the following form. By default, ``typ=`n`` and the function use LU factorisation with partial pivoting when ``a`` is square and QR factorisation with column pivoting otherwise. The number of rows of ``a`` must equal the number of rows of ``b``. If ``a`` is a upper(lower) triangular matrix, the function calls the ``solve_triangular`` function when ``typ=`u``(``typ=`l``).</p><p>.. math:: AX = B</p><p>By default, ``trans = false`` indicates no transpose. If ``trans = true``, then function will solve ``A^T * x = b`` for real matrices; ``A^H * x = b`` for complex matrices.</p><p>.. math:: A^H X = B</p><p>The associated operator is ``/@``, so you can simply use ``a /@ b`` to solve the linear equation system to get ``x``. Please refer to :doc:`owl_operator`.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-linreg" class="anchored"><a href="#val-linreg" class="anchor"></a><code><span><span class="keyword">val</span> linreg : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> * <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>``linreg x y -&gt; (a, b)`` solves ``y = a + b*x`` using Ordinary Least Squares.</p><p>.. math:: Y = A + BX</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sylvester" class="anchored"><a href="#val-sylvester" class="anchor"></a><code><span><span class="keyword">val</span> sylvester : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``sylvester a b c`` solves a Sylvester equation in the following form. The function calls LAPACKE function ``trsyl`` solve the system.</p><p>.. math:: AX + XB = C</p><p>Parameters: * ``a`` : ``m x m`` matrix A. * ``b`` : ``n x n`` matrix B. * ``c`` : ``m x n`` matrix C.</p><p>Returns: * ``x`` : ``m x n`` matrix X.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lyapunov" class="anchored"><a href="#val-lyapunov" class="anchor"></a><code><span><span class="keyword">val</span> lyapunov : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``lyapunov a q`` solves a continuous Lyapunov equation in the following form. The function calls LAPACKE function ``trsyl`` solve the system. In Matlab, the same function is called ``lyap``.</p><p>.. math:: AX + XA^H = Q</p><p>Parameters: * ``a`` : ``m x m`` matrix A. * ``q`` : ``n x n`` matrix Q.</p><p>Returns: * ``x`` : ``m x n`` matrix X.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-discrete_lyapunov" class="anchored"><a href="#val-discrete_lyapunov" class="anchor"></a><code><span><span class="keyword">val</span> discrete_lyapunov : 
  <span>?solver:<span>[ `default <span>| `bilinear</span> <span>| `direct</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``discrete_lyapunov a q`` solves a discrete-time Lyapunov equation in the following form.</p><p>.. math:: X - AXA^H = Q</p><p>Parameters: * ``a`` : ``m x m`` matrix A. * ``q`` : ``n x n`` matrix Q.</p><p>Returns: * ``x`` : ``m x n`` matrix X.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-care" class="anchored"><a href="#val-care" class="anchor"></a><code><span><span class="keyword">val</span> care : 
  <span>?diag_r:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( float, <span class="type-var">'a</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( float, <span class="type-var">'a</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( float, <span class="type-var">'a</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( float, <span class="type-var">'a</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( float, <span class="type-var">'a</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``care ?diag_r a b q r`` solves the continuous-time algebraic Riccati equation system in the following form. The algorithm is based on :cite:`laub1979schur`.</p><p>.. math:: A^T X + X A − X B R^</p><p>1</p><p>}</p><p>B^T X + Q = 0</p><p>Parameters: * ``a`` : real cofficient matrix A. * ``b`` : real cofficient matrix B. * ``q`` : real cofficient matrix Q. * ``r`` : real cofficient matrix R. R must be non-singular. * ``diag_r`` : true if R is a diagonal matrix, false by default.</p><p>Returns: * ``x`` : a solution matrix X.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dare" class="anchored"><a href="#val-dare" class="anchor"></a><code><span><span class="keyword">val</span> dare : 
  <span>?diag_r:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( float, <span class="type-var">'a</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( float, <span class="type-var">'a</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( float, <span class="type-var">'a</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( float, <span class="type-var">'a</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( float, <span class="type-var">'a</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``dare ?diag_r a b q r`` solves the discrete-time algebraic Riccati equation system in the following form. The algorithm is based on :cite:`laub1979schur`.</p><p>.. math:: A^T X A - X - (A^T X B) (B^T X B + R)^</p><p>1</p><p>}</p><p>(B^T X A) + Q = 0</p><p>Parameters: * ``a`` : real cofficient matrix A. A must be non-singular. * ``b`` : real cofficient matrix B. * ``q`` : real cofficient matrix Q. * ``r`` : real cofficient matrix R. R must be non-singular. * ``diag_r`` : true if R is a diagonal matrix, false by default.</p><p>Returns: * ``x`` : a symmetric solution matrix X.</p></div></div><h6 id="low-level-factorisation-functions"><a href="#low-level-factorisation-functions" class="anchor"></a>Low-level factorisation functions</h6><div class="odoc-spec"><div class="spec value" id="val-lufact" class="anchored"><a href="#val-lufact" class="anchor"></a><code><span><span class="keyword">val</span> lufact : 
  <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> * <span><span>( int32, <span class="xref-unresolved">Stdlib</span>.Bigarray.int32_elt )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``lufact x -&gt; (a, ipiv)`` calculates LU factorisation with pivot of a general matrix ``x``.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-qrfact" class="anchored"><a href="#val-qrfact" class="anchor"></a><code><span><span class="keyword">val</span> qrfact : 
  <span>?pivot:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> * <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> * <span><span>( int32, <span class="xref-unresolved">Stdlib</span>.Bigarray.int32_elt )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``qrfact x -&gt; (a, tau, jpvt)`` calculates QR factorisation of a general matrix ``x``.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-bkfact" class="anchored"><a href="#val-bkfact" class="anchor"></a><code><span><span class="keyword">val</span> bkfact : 
  <span>?upper:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?symmetric:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?rook:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> * <span><span>( int32, <span class="xref-unresolved">Stdlib</span>.Bigarray.int32_elt )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``bk x -&gt; (a, ipiv)`` calculates Bunch-Kaufman factorisation of ``x``. If ``symmetric = true`` then ``x`` is symmetric, if ``symmetric = false`` then ``x`` is hermitian. If ``rook = true`` the function performs bounded Bunch-Kaufman (&quot;rook&quot;) diagonal pivoting method, if ``rook = false`` then Bunch-Kaufman diagonal pivoting method is used. ``a`` contains details of the block-diagonal matrix ``d`` and the multipliers used to obtain the factor ``u`` (or ``l``).</p><p>The ``upper`` indicates whether the upper or lower triangular part of ``x`` is stored and how ``x`` is factored. If ``upper = true`` then upper triangular part is stored: ``x = u*d*u'`` else ``x = l*d*l'``.</p><p>For ``ipiv``, it indicates the details of the interchanges and the block structure of ``d``. Please refer to the function ``sytrf``, ``hetrf`` in MKL documentation for more details.</p></div></div><h6 id="matrix-functions"><a href="#matrix-functions" class="anchor"></a>Matrix functions</h6><div class="odoc-spec"><div class="spec value" id="val-mpow" class="anchored"><a href="#val-mpow" class="anchor"></a><code><span><span class="keyword">val</span> mpow : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``mpow x r`` returns the dot product of square matrix ``x`` with itself ``r`` times, and more generally raises the matrix to the ``r``th power. ``r`` is a float that must be equal to an integer; it can be be negative, zero, or positive. Non-integer exponents are not yet implemented. (If ``r`` is negative, ``mpow`` calls ``inv``, and warnings in documentation for ``inv`` apply.)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-expm" class="anchored"><a href="#val-expm" class="anchor"></a><code><span><span class="keyword">val</span> expm : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``expm x`` computes the matrix exponential of ``x`` defined by</p><p>.. math:: e^x = \sum_<code>k=0</code>^<code>\infty</code> \frac</p><p></p><p><code>k!</code> x^k</p><p>The function implements the scaling and squaring algorithm which uses Padé approximation to compute the matrix exponential :cite:`al2009new`.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sinm" class="anchored"><a href="#val-sinm" class="anchor"></a><code><span><span class="keyword">val</span> sinm : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``sinm x`` computes the matrix sine of input ``x``. The function uses ``expm`` to compute the matrix exponentials.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cosm" class="anchored"><a href="#val-cosm" class="anchor"></a><code><span><span class="keyword">val</span> cosm : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``cosm x`` computes the matrix cosine of input ``x``. The function uses ``expm`` to compute the matrix exponentials.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tanm" class="anchored"><a href="#val-tanm" class="anchor"></a><code><span><span class="keyword">val</span> tanm : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``tanm x`` computes the matrix tangent of input ``x``. The function uses ``expm`` to compute the matrix exponentials.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sincosm" class="anchored"><a href="#val-sincosm" class="anchor"></a><code><span><span class="keyword">val</span> sincosm : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> * <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``sincosm x`` returns both matrix sine and cosine of ``x``.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sinhm" class="anchored"><a href="#val-sinhm" class="anchor"></a><code><span><span class="keyword">val</span> sinhm : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``sinhm x`` computes the hyperbolic matrix sine of input ``x``. The function uses ``expm`` to compute the matrix exponentials.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-coshm" class="anchored"><a href="#val-coshm" class="anchor"></a><code><span><span class="keyword">val</span> coshm : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``coshm x`` computes the hyperbolic matrix cosine of input ``x``. The function uses ``expm`` to compute the matrix exponentials.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tanhm" class="anchored"><a href="#val-tanhm" class="anchor"></a><code><span><span class="keyword">val</span> tanhm : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``tanhm x`` computes the hyperbolic matrix tangent of input ``x``. The function uses ``expm`` to compute the matrix exponentials.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sinhcoshm" class="anchored"><a href="#val-sinhcoshm" class="anchor"></a><code><span><span class="keyword">val</span> sinhcoshm : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> * <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``sinhcoshm x`` returns both hyperbolic matrix sine and cosine of ``x``.</p></div></div><h6 id="helper-functions"><a href="#helper-functions" class="anchor"></a>Helper functions</h6><div class="odoc-spec"><div class="spec value" id="val-select_ev" class="anchored"><a href="#val-select_ev" class="anchor"></a><code><span><span class="keyword">val</span> select_ev : 
  <span><span>[ `LHP <span>| `RHP</span> <span>| `UDI</span> <span>| `UDO</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( int32, <span class="xref-unresolved">Stdlib</span>.Bigarray.int32_elt )</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>``select_ev keyword ev`` generates a logical vector (of same shape as ``ev``) from eigen values ``ev`` according to the passed in keywards.</p><ul><li>``LHP``: Left-half plane :math:`(real(e) &lt; 0)`.</li><li>``RHP``: Left-half plane :math:`(real(e) \ge 0)`.</li><li>``UDI``: Left-half plane :math:`(abs(e) &lt; 1)`.</li><li>``UDO``: Left-half plane :math:`(abs(e) \ge 0)`.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-peakflops" class="anchored"><a href="#val-peakflops" class="anchor"></a><code><span><span class="keyword">val</span> peakflops : <span>?n:int <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>``peakflops ()`` returns the peak number of float point operations using ``Owl_cblas_basic.dgemm`` function. The default matrix size is ``2000 x 2000``, but you can change this by setting ``n`` to other numbers as you like.</p></div></div></details></div></div></body></html>