<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Linalg (owl-base.Owl_neural_compiler.Make.E.Graph.Optimiser.Operator.Linalg)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../../../../index.html">owl-base</a> &#x00BB; <a href="../../../../../../index.html">Owl_neural_compiler</a> &#x00BB; <a href="../../../../../index.html">Make</a> &#x00BB; <a href="../../../../index.html">E</a> &#x00BB; <a href="../../../index.html">Graph</a> &#x00BB; <a href="../../index.html">Optimiser</a> &#x00BB; <a href="../index.html">Operator</a> &#x00BB; Linalg</nav><header class="odoc-preamble"><h1>Module <code><span>Operator.Linalg</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec value anchored" id="val-inv"><a href="#val-inv" class="anchor"></a><code><span><span class="keyword">val</span> inv : <span><a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a></span></code></div><div class="spec-doc"><p><code>inv a</code> computes the inverse of the matrix <code>a</code>. Returns a new array representing the inverse matrix.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-logdet"><a href="#val-logdet" class="anchor"></a><code><span><span class="keyword">val</span> logdet : <span><a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Symbol/Shape/Type/index.html#type-elt">Symbol.Shape.Type.elt</a></span></code></div><div class="spec-doc"><p><code>logdet a</code> computes the natural logarithm of the determinant of the matrix <code>a</code>. Returns the logarithm of the determinant as a scalar.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-chol"><a href="#val-chol" class="anchor"></a><code><span><span class="keyword">val</span> chol : <span><span class="optlabel">?upper</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a></span></code></div><div class="spec-doc"><p><code>chol ?upper a</code> performs the Cholesky decomposition of the positive-definite matrix <code>a</code>.</p><ul><li><code>upper</code> specifies whether to return the upper or lower triangular matrix. If <code>upper</code> is true, returns the upper triangular matrix, otherwise the lower triangular matrix. Returns a new array representing the Cholesky factor.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-qr"><a href="#val-qr" class="anchor"></a><code><span><span class="keyword">val</span> qr : <span><a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a> * <a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a></span></code></div><div class="spec-doc"><p><code>qr a</code> performs the QR decomposition of the matrix <code>a</code>. Returns a tuple of two arrays (Q, R), where <code>Q</code> is an orthogonal matrix and <code>R</code> is an upper triangular matrix.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lq"><a href="#val-lq" class="anchor"></a><code><span><span class="keyword">val</span> lq : <span><a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a> * <a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a></span></code></div><div class="spec-doc"><p><code>lq a</code> performs the LQ decomposition of the matrix <code>a</code>. Returns a tuple of two arrays (L, Q), where <code>L</code> is a lower triangular matrix and <code>Q</code> is an orthogonal matrix.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-svd"><a href="#val-svd" class="anchor"></a><code><span><span class="keyword">val</span> svd : 
  <span><span class="optlabel">?thin</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a> * <a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a> * <a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a></span></code></div><div class="spec-doc"><p><code>svd ?thin a</code> performs the Singular Value Decomposition (SVD) of the matrix <code>a</code>.</p><ul><li><code>thin</code> specifies whether to return the reduced form of the SVD. Returns a tuple of three arrays (U, S, V), where <code>U</code> and <code>V</code> are orthogonal matrices, and <code>S</code> is a diagonal matrix containing the singular values.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sylvester"><a href="#val-sylvester" class="anchor"></a><code><span><span class="keyword">val</span> sylvester : 
  <span><a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a></span></code></div><div class="spec-doc"><p><code>sylvester a b c</code> solves the Sylvester equation A*X + X*B = C for the unknown matrix X. Returns a new array representing the solution matrix X.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lyapunov"><a href="#val-lyapunov" class="anchor"></a><code><span><span class="keyword">val</span> lyapunov : 
  <span><a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a></span></code></div><div class="spec-doc"><p><code>lyapunov a q</code> solves the continuous Lyapunov equation A*X + X*A^T = Q for the unknown matrix X. Returns a new array representing the solution matrix X.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-discrete_lyapunov"><a href="#val-discrete_lyapunov" class="anchor"></a><code><span><span class="keyword">val</span> discrete_lyapunov : 
  <span><span class="optlabel">?solver</span>:<span>[ `default <span>| `bilinear</span> <span>| `direct</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a></span></code></div><div class="spec-doc"><p><code>discrete_lyapunov ?solver a q</code> solves the discrete Lyapunov equation A*X*A^T - X + Q = 0 for the unknown matrix X.</p><ul><li><code>solver</code> specifies the method to use: `default`, `bilinear`, or `direct`. Returns a new array representing the solution matrix X.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-linsolve"><a href="#val-linsolve" class="anchor"></a><code><span><span class="keyword">val</span> linsolve : 
  <span><span class="optlabel">?trans</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?typ</span>:<span>[ `n <span>| `u</span> <span>| `l</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a></span></code></div><div class="spec-doc"><p><code>linsolve ?trans ?typ a b</code> solves the linear system A*X = B for the unknown matrix X.</p><ul><li><code>trans</code> specifies whether to transpose the matrix A.</li><li><code>typ</code> specifies the type of matrix A: `n` for normal, `u` for upper triangular, and `l` for lower triangular. Returns a new array representing the solution matrix X.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-care"><a href="#val-care" class="anchor"></a><code><span><span class="keyword">val</span> care : 
  <span><span class="optlabel">?diag_r</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a></span></code></div><div class="spec-doc"><p><code>care ?diag_r a b q r</code> solves the Continuous-time Algebraic Riccati Equation (CARE) A*X + X*A^T - X*B*R^-1*B^T*X + Q = 0 for the unknown matrix X.</p><ul><li><code>diag_r</code> if true, <code>R</code> is assumed to be diagonal. Returns a new array representing the solution matrix X.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-dare"><a href="#val-dare" class="anchor"></a><code><span><span class="keyword">val</span> dare : 
  <span><span class="optlabel">?diag_r</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../Symbol/Shape/Type/index.html#type-arr">Symbol.Shape.Type.arr</a></span></code></div><div class="spec-doc"><p><code>dare ?diag_r a b q r</code> solves the Discrete-time Algebraic Riccati Equation (DARE) A*X*A^T - X - (A*X*B^T)*inv(B*X*B^T + R)*(A*X*B^T)^T + Q = 0 for the unknown matrix X.</p><ul><li><code>diag_r</code> if true, <code>R</code> is assumed to be diagonal. Returns a new array representing the solution matrix X.</li></ul></div></div></div></body></html>
